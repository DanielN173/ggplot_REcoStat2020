<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>ggplot2</title>
    <meta charset="utf-8" />
    <link href="libs/remark-css/default.css" rel="stylesheet" />
    <script src="libs/xaringanExtra-logo/logo.js"></script>
    <link rel="stylesheet" href="custom-fonts.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# <code>ggplot2</code>
## Maria Novosolov
### 21-04-2020

---




<style type="text/css">
.xaringan-extra-logo {
  width: 110px;
  height: 128px;
  z-index: 0;
  background-image: url('img/logo.png');
  background-size: contain;
  background-repeat: no-repeat;
  position: absolute;
  top:1em;right:1em;
}
</style>

class: center, middle

# The idea behind `ggplot2`

Combining all the good and leaving out all the bad of all base R packages for plotting

---

# Some examples

![](img/Picture1.png)

---

# What `ggplot2` can do?

Almost anything you want it

.center[
&lt;img src="img/15912721.png" width=40%&gt;
]
---

# What `ggplot2` can't do?

It can't choose for you which graphics represent your data best

.center[
&lt;img src="img/choose_graphics.jpg" width=50%&gt;
]

---

# The basics of `ggplot2`

* Based on the Grammar of Graphics (Wilkinson, 2005)

* Based on a layer system

* Flexible set of components for creating any type of graphics

---

# Specification

Components of a graphic:

* **DATA** - the dataset that will be used for the other components

* **TRANS** - variable transformation

* **SCALE** - scale transformation

* **ELEMENT** - graphs and their aesthetic attributes

* **COORD** - a coordinate system

* **GUIDE** - one or more guides

---

class: center, middle

## Install the package using `install.packages("ggplot2")`

## load the package with `library(ggplot2)`

---

# Two options of working with the package

**`qplot()`** - quick and dirty plotting. Limitted options

**`ggplot()`** - base function for more versetile plotting

---

.center[
# `qplot()`
]

* Syntex similar the the `base` R `plot()`

* **x** == predictor

* **y** == response

* **data** == the data frame that holds the variables to plot


```r
qplot(x,y,data = mydata)
```

---

# Example using the `iris` dataset



```r
data(iris)
qplot(x = Sepal.Width,y = Petal.Width,data = iris)
```

![](ggplot2_files/figure-html/unnamed-chunk-2-1.png)&lt;!-- --&gt;

---
# The building blocks of `ggplot()`


A .green[**plot**] is made up of multiple layers. 

A .green[**layer**] consists of data, a set of
mappings between variables and
.green[**aes**]thetics, a .green[**geom**]etric object and a
.green[**stat**]istical transformation.

.green[**Scales**] control the details of the mapping.
All components are independent and
reusable.

---

# Adventages of the layers system

* Change a single feature at a time

* Create new types of plots on the fly

* Cure against immobility

* Developers can easily develop new layers without affecting other layers

---

class: inverse, center, middle

# Lets dive into the syntex


![](img/dive.png)

---

# Anatomy of the plot

1. .green[**Data**] – the dataset name that you want to present

2. .green[**Aesthetics**] – the variables you want to use in the plot

3. .green[**Geom**] – the type of plot you want do

4. **Themes** – control presentation of non-data elements

5. **Stat** – statistical transformations 

6. **Scale** – define parameters of the plot (exp: x-axis, color, etc.)

.bottom-left[
*The green variables are mandatory to create a plot
]
---

# 1. Data

In `ggplot()` you always have to specify what data you are using for the plot.

Thus, you always work with data.frames/tibbles


```r
ggplot(data = iris,aes(x = Sepal.Width,y = Petal.Width))
```

![](ggplot2_files/figure-html/unnamed-chunk-3-1.png)&lt;!-- --&gt;

.footnote[
*R function are placment based which means it anticipates the parameters type based on location. So you dont have to write "data", "x", "y" if you place them in the right place
]
---

# 2. Aesthetic mapping

In `ggplot()` land it means "something you can see" and it includes:

* Position (x and y)

* Color (a name of a color or a vector that will be used for color)

* Fill (a name of a color or a vector that will be used for color)

* Shape (a name of a shape or a vector that will be used for shape)

* Line type

* Size

---

# 3. Geometric obejs aka `geom`

* A geom can only display certain aesthetics

* A plot must have at least one geom but there is no upper limit

---

# Lets look at some examples

---
## `geom_histogram()`



```r
ggplot(data = iris,aes(x = Sepal.Width))+
  geom_histogram()
```

```
## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`.
```

![](ggplot2_files/figure-html/unnamed-chunk-4-1.png)&lt;!-- --&gt;
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="libs/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"ratio": "16:9"
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
